import numpy as np
import matplotlib.pyplot as plt
from queue import PriorityQueue
import time

explored=[]

def plot_grid(grid, start_node, goal_node, path):
    fig, ax = plt.subplots(figsize=(10, 10))

    disp = np.zeros((*grid.shape, 3), dtype=np.uint8)

    disp[grid == 1]  = [0, 0, 0]         # black = wall
    disp[grid == 0]  = [255, 255, 255]   # white = free
    disp[grid == -1] = [128, 128, 128]   # grey = unknown

    # Draw A* path in red
    for (row, col) in path:
        disp[row, col] = [255, 0, 0]

    # Start = blue, Goal = green
    disp[start_node] = [0, 0, 255]
    disp[goal_node]  = [0, 255, 0]

    ax.imshow(disp, origin='upper')
    rows, cols = grid.shape
    ax.set_xticks(np.arange(-0.5, cols, 1), minor=True)
    ax.set_yticks(np.arange(-0.5, rows, 1), minor=True)
    ax.set_title("A* Path on Occupancy Grid")
    plt.legend(
    [plt.Line2D([0], [0], color='black', lw=5),
     plt.Line2D([0], [0], color='white', lw=5),
     plt.Line2D([0], [0], color='grey',  lw=5)],
    ["Wall", "Free", "Unknown"])
    plt.show()

    #Heuristic using distance between goal and current location
def heuristic(node1, node2):
    (x, y) = node1
    (x2, y2) = node2
    return abs(x - x2) + abs(y - y2)


def neighbours(node=tuple):
    # nodes from all sides, vertical is inverted since origin is upper
    (row, col) = node
    top_node    = (row - 1, col)
    bottom_node = (row + 1, col)
    left_node   = (row, col - 1)
    right_node  = (row, col + 1)
    return [top_node, bottom_node, left_node, right_node]


def is_valid_node(node: tuple, grid: np.array):
    (row, col) = node
    rows, cols = grid.shape
    if rows > row >= 0:
        if cols > col >= 0:
            # only allow free cells 0 (Space) and treating 1 and -1 as blocked
            if grid[row][col] == 0:
                return True
    return False


def Astar(start_node, goal_node, grid):
    open_list = PriorityQueue()
    open_list.put((0, start_node))

    closed_list = set()
    parents = {start_node: None}
    cost_from_start_node = {start_node: 0}

    explored = []

    while not open_list.empty():
        priority_cost, current_node = open_list.get()
        explored.append(current_node)

        if current_node == goal_node:
            break

        if current_node in closed_list:
            continue
        else:
            closed_list.add(current_node)

        current_cost = cost_from_start_node[current_node]

        for next_node in neighbours(current_node):
            if is_valid_node(next_node, grid) and next_node not in closed_list:
                new_cost = current_cost + 1
                if next_node not in cost_from_start_node or new_cost < cost_from_start_node[next_node]:
                    cost_from_start_node[next_node] = new_cost
                    parents[next_node] = current_node
                    priority_cost = new_cost + heuristic(next_node, goal_node)
                    open_list.put((priority_cost, next_node))

    path = []
    current_node = goal_node

    if current_node not in parents:
        return path, explored

    while current_node != start_node:
        path.append(current_node)
        current_node = parents.get(current_node)
        if current_node is None:
            return [], explored

    path.append(start_node)
    path.reverse()
    return path, explored


if __name__ == "__main__":
    # Load the occupancy grid generated by scangrid.py
    grid = np.load("occupancy_grid_numpy.npy")
    print("Grid shape:", grid.shape)

    # Define start and goal nodes 
    start_node = (50, 32)
    goal_node  = (15, 57)

    # Run A* algorithm and recording it
    start_time=time.time()
    path, explored = Astar(start_node, goal_node, grid)
    end_time=time.time()

    print(f'A* Time: {end_time-start_time} seconds')
    print("Shortest path:", path[::]) # Shortening the path since it's long
    print("Explored Nodes: ",len(explored))
    print("Path length:", len(path))

    # Plotting
    plot_grid(grid, start_node, goal_node, path)

